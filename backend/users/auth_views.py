"""
Authentication views for JWT-based authentication.
"""
from rest_framework import status, generics, serializers
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.response import Response
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework_simplejwt.views import TokenObtainPairView
from django.contrib.auth import get_user_model
from django.contrib.auth.password_validation import validate_password
from django.core.exceptions import ValidationError
from .serializers import UserSerializer, EmailTokenObtainPairSerializer
import logging
import os

logger = logging.getLogger(__name__)
User = get_user_model()


class CustomTokenObtainPairView(TokenObtainPairView):
    """
    Custom token obtain view that returns user data along with tokens.
    Supports email-based login.
    """
    serializer_class = EmailTokenObtainPairSerializer
    
    def post(self, request, *args, **kwargs):
        # Log incoming request data for debugging
        logger.info(f"Login request received - Data keys: {list(request.data.keys())}, Email: {request.data.get('email', 'NOT PROVIDED')}")
        
        # Get serializer and validate
        serializer = self.get_serializer(data=request.data)
        
        # Validate without raising exception first to get better error handling
        if not serializer.is_valid():
            logger.warning(f"Login validation failed: {serializer.errors}")
            error_detail = serializer.errors
            
            # Extract error message from different error formats
            if isinstance(error_detail, dict):
                # Check for non_field_errors first
                if 'non_field_errors' in error_detail:
                    error_message = error_detail['non_field_errors'][0] if isinstance(error_detail['non_field_errors'], list) else str(error_detail['non_field_errors'])
                elif 'email' in error_detail:
                    error_message = error_detail['email'][0] if isinstance(error_detail['email'], list) else str(error_detail['email'])
                elif 'password' in error_detail:
                    error_message = error_detail['password'][0] if isinstance(error_detail['password'], list) else str(error_detail['password'])
                else:
                    # Get first error message from dict
                    first_key = list(error_detail.keys())[0] if error_detail else None
                    if first_key:
                        first_value = error_detail[first_key]
                        error_message = first_value[0] if isinstance(first_value, list) else str(first_value)
                    else:
                        error_message = 'Invalid credentials'
            elif isinstance(error_detail, list):
                error_message = error_detail[0] if error_detail else 'Invalid credentials'
            else:
                error_message = str(error_detail) if error_detail else 'Invalid credentials'
            
            logger.warning(f"Returning 401 error: {error_message}")
            return Response(
                {'error': 'Invalid credentials', 'detail': error_message},
                status=status.HTTP_401_UNAUTHORIZED
            )
        
        # Validation passed, get user and tokens
        try:
            # Get the user from the validated serializer
            user = getattr(serializer, 'user', None)
            if not user:
                logger.error("User not found in serializer after validation")
                return Response(
                    {'error': 'Authentication failed', 'detail': 'User not found after validation'},
                    status=status.HTTP_401_UNAUTHORIZED
                )
            
            # Refresh user from database to get latest verification status
            user.refresh_from_db()
            logger.info(f"User {user.email} - is_verified: {user.is_verified}, is_active: {user.is_active}")
            
            # Get tokens from validated data (generated by serializer)
            validated_data = serializer.validated_data
            access_token = validated_data.get('access')
            refresh_token = validated_data.get('refresh')
            
            if not access_token or not refresh_token:
                logger.error("Tokens not found in validated data")
                return Response(
                    {'error': 'Authentication failed', 'detail': 'Failed to generate tokens'},
                    status=status.HTTP_500_INTERNAL_SERVER_ERROR
                )
            
            # Check if user has verified their email
            if not user.is_verified:
                logger.warning(f"Login attempt by unverified user: {user.email}")
                return Response(
                    {
                        'error': 'Email not verified',
                        'detail': 'Please verify your email address before logging in. Check your inbox for the verification link.',
                        'requires_verification': True,
                        'email': user.email
                    },
                    status=status.HTTP_403_FORBIDDEN
                )
            
            # Serialize user data
            user_serializer = UserSerializer(user)
            
            # Build response with tokens and user data
            response_data = {
                'access': access_token,
                'refresh': refresh_token,
                'user': user_serializer.data
            }
            
            logger.info(f"User {user.email} logged in successfully")
            
            return Response(response_data, status=status.HTTP_200_OK)
            
        except Exception as e:
            logger.error(f"Login error after validation: {e}", exc_info=True)
            error_message = str(e) if e else 'Authentication failed'
            return Response(
                {'error': 'Authentication failed', 'detail': error_message},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


@api_view(['POST'])
@permission_classes([AllowAny])
def register(request):
    """
    Register a new user.
    
    Expected payload:
    {
        "username": "user123",
        "email": "user@example.com",
        "password": "securepassword",
        "first_name": "John",
        "last_name": "Doe"
    }
    """
    logger.info(f"Registration attempt - Data received: {list(request.data.keys())}")
    
    username = request.data.get('username', '').strip()
    email = request.data.get('email', '').strip()
    password = request.data.get('password', '')
    first_name = request.data.get('first_name', '').strip()
    last_name = request.data.get('last_name', '').strip()
    
    # Validate required fields
    if not username:
        logger.warning("Registration failed: Username missing")
        return Response(
            {'error': 'Username is required'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    if not email:
        logger.warning("Registration failed: Email missing")
        return Response(
            {'error': 'Email is required'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    if not password:
        logger.warning("Registration failed: Password missing")
        return Response(
            {'error': 'Password is required'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    # Basic email format validation
    if '@' not in email or '.' not in email.split('@')[-1]:
        logger.warning(f"Registration failed: Invalid email format - {email}")
        return Response(
            {'error': 'Invalid email format'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    # Check if user already exists
    if User.objects.filter(username=username).exists():
        return Response(
            {'error': 'Username already exists'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    if User.objects.filter(email=email).exists():
        return Response(
            {'error': 'Email already exists'},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    # Validate password
    try:
        validate_password(password, user=None)
    except ValidationError as e:
        error_messages = list(e.messages)
        logger.warning(f"Registration failed: Password validation failed - {error_messages}")
        return Response(
            {'error': 'Password validation failed', 'details': error_messages},
            status=status.HTTP_400_BAD_REQUEST
        )
    
    # Create user
    try:
        user = User.objects.create_user(
            username=username,
            email=email,
            password=password,
            first_name=first_name,
            last_name=last_name,
            is_verified=False  # User needs to verify email
        )
        
        # Send verification email (DO NOT generate tokens - user must verify first)
        try:
            from .verification_views import generate_verification_token
            from .models import EmailVerificationToken
            from django.utils import timezone
            from datetime import timedelta
            from django.conf import settings
            
            # Generate verification token
            token = generate_verification_token()
            expires_at = timezone.now() + timedelta(hours=24)
            
            # Create verification token
            EmailVerificationToken.objects.create(
                user=user,
                token=token,
                expires_at=expires_at
            )
            
            # Build verification URL - redirect to frontend page
            domain_url = settings.DOMAIN_URL or request.build_absolute_uri('/')[:-1]
            # Frontend URL for verification page
            import os
            frontend_url = os.getenv('NEXT_PUBLIC_APP_URL', domain_url.replace('/api', ''))
            verification_link = f"{frontend_url}/check-email?token={token}"
            
            # Send verification email
            from .email_service import send_verification_email
            email_sent = send_verification_email(user, verification_link)
            if email_sent:
                logger.info(f"Verification email sent successfully to {user.email}")
            else:
                logger.warning(f"Verification email could not be sent to {user.email}. User can request a new verification email later.")
        except Exception as email_error:
            # Log error but don't fail registration
            logger.error(f"Failed to send verification email: {email_error}", exc_info=True)
        
        # Serialize user data (without sensitive info)
        user_serializer = UserSerializer(user)
        
        logger.info(f"New user registered: {user.email} - awaiting email verification")
        
        # Return response WITHOUT tokens - user must verify email first
        return Response({
            'user': {
                'id': str(user.id),
                'email': user.email,
                'username': user.username,
                'is_verified': user.is_verified,
            },
            'message': 'Registration successful! Please check your email to verify your account before logging in.',
            'requires_verification': True
        }, status=status.HTTP_201_CREATED)
        
    except Exception as e:
        logger.error(f"Error registering user: {e}", exc_info=True)
        return Response(
            {'error': f'Failed to register user: {str(e)}'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )


@api_view(['POST'])
@permission_classes([IsAuthenticated])
def logout(request):
    """
    Logout user by blacklisting the refresh token.
    
    Expected payload:
    {
        "refresh": "refresh_token_string"
    }
    """
    try:
        refresh_token = request.data.get('refresh')
        if refresh_token:
            token = RefreshToken(refresh_token)
            token.blacklist()
            logger.info(f"User {request.user.email} logged out")
            return Response(
                {'message': 'Successfully logged out'},
                status=status.HTTP_200_OK
            )
        else:
            return Response(
                {'error': 'Refresh token is required'},
                status=status.HTTP_400_BAD_REQUEST
            )
    except Exception as e:
        logger.error(f"Error during logout: {e}")
        return Response(
            {'error': 'Failed to logout'},
            status=status.HTTP_400_BAD_REQUEST
        )


@api_view(['GET'])
@permission_classes([IsAuthenticated])
def me(request):
    """
    Get current authenticated user's profile.
    """
    try:
        user_serializer = UserSerializer(request.user)
        return Response({
            'user': user_serializer.data
        }, status=status.HTTP_200_OK)
    except Exception as e:
        logger.error(f"Error fetching user profile: {e}")
        return Response(
            {'error': 'Failed to fetch user profile'},
            status=status.HTTP_500_INTERNAL_SERVER_ERROR
        )

